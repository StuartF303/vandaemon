@page "/"
@using MudBlazor.Utilities
@using VanDaemon.Core.Entities
@using VanDaemon.Web.Shared
@inject HttpClient Http
@inject TelemetryService Telemetry
@inject ISnackbar Snackbar
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<PageTitle>Dashboard - VanDaemon</PageTitle>

<style>
    .dashboard-page {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        position: relative;
        background: var(--mud-palette-background);
        overflow: hidden;
    }

    .diagram-area {
        flex: 1;
        position: relative;
        width: 100%;
        overflow: hidden;
        min-height: 0;
    }

    .van-diagram-container {
        position: relative;
        width: 100%;
        height: 100%;
    }

    .van-diagram-background {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: contain;
        z-index: 1;
        pointer-events: none;
    }

    .overlay-item {
        z-index: 10;
        position: absolute;
    }

    .overlay-item.edit-mode {
        z-index: 15;
    }

    .overlay-content {
        pointer-events: auto;
    }

    /* Consistent card styling for all movable objects */
    .overlay-card {
        background: var(--mud-palette-surface);
        border-radius: 12px;
        box-shadow: var(--mud-elevation-6);
        width: 140px;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    /* Row 1: Icon and Name in grid */
    .overlay-header {
        display: grid;
        grid-template-columns: 40px 1fr;
        gap: 8px;
        align-items: center;
    }

    .overlay-icon {
        font-size: 32px !important;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .overlay-name {
        font-weight: 600;
        font-size: 0.875rem;
        line-height: 1.2;
        overflow: hidden;
        text-overflow: ellipsis;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
    }

    /* Row 2: Control area */
    .overlay-control {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 40px;
    }

    /* Tank bar graph */
    .tank-bar-container {
        width: 100%;
        height: 32px;
        background: var(--mud-palette-background-grey);
        border-radius: 8px;
        position: relative;
        overflow: hidden;
        border: 1px solid rgba(0, 0, 0, 0.12);
    }

    [data-theme="dark"] .tank-bar-container {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.12);
    }

    .tank-bar-fill {
        height: 100%;
        transition: width 0.3s ease;
        border-radius: 7px;
    }

    .tank-bar-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-weight: 700;
        font-size: 0.875rem;
        color: var(--mud-palette-text-primary);
        text-shadow: 0 0 3px var(--mud-palette-surface);
        z-index: 1;
    }

    /* Control switch centered */
    .control-switch {
        transform: scale(1.2);
    }

</style>

<div class="dashboard-page">
    <DashboardMenu IsEditMode="@isEditMode"
                   IsEditModeChanged="@((bool value) => isEditMode = value)"
                   ShowFullscreenOption="false"
                   IsFullscreen="false"
                   ToolbarPosition="@toolbarPosition" />

    <!-- Van Diagram Container -->
    <div class="diagram-area"
         @onmousemove="OnMouseMove"
         @onmouseup="OnMouseUp"
         @ontouchmove="OnTouchMove"
         @ontouchend="OnTouchEnd"
         @ontouchmove:preventDefault="isEditMode"
         @ontouchend:preventDefault="isEditMode">
        <div class="van-diagram-container" @ref="diagramContainer">
            @if (!string.IsNullOrEmpty(backgroundImage))
            {
                <img src="@backgroundImage" alt="Van Diagram" class="van-diagram-background" />
            }
            else
            {
                <div style="text-align: center; padding: 50px; background: var(--mud-palette-background-grey); border-radius: 8px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1;">
                    <MudIcon Icon="@Icons.Material.Filled.DirectionsCar" Size="Size.Large" Style="font-size: 120px; opacity: 0.3;" />
                    <MudText Typo="Typo.h6" Class="mt-4">No background image configured</MudText>
                    <MudText Typo="Typo.body2">Go to Settings to upload a van diagram</MudText>
                </div>
            }

            <!-- Overlays for tanks and controls -->
            @foreach (var overlay in overlays)
            {
                <div class="overlay-item @(isEditMode ? "edit-mode" : "")"
                     style="position: absolute; left: @(overlay.X)%; top: @(overlay.Y)%; transform: translate(-50%, -50%); cursor: @(isEditMode ? "move" : "pointer"); user-select: none; touch-action: none;"
                     @onclick="() => OnOverlayClick(overlay)"
                     @onmousedown="(e) => OnMouseDown(e, overlay)"
                     @onmousedown:preventDefault="isEditMode"
                     @ontouchstart="(e) => OnTouchStart(e, overlay)"
                     @ontouchstart:preventDefault="isEditMode">

                    @if (overlay.Type == OverlayType.Tank)
                    {
                        <div class="overlay-content overlay-card">
                            <!-- Row 1: Icon and Name -->
                            <div class="overlay-header">
                                <MudIcon Icon="@overlay.Icon" Color="@GetOverlayColor(overlay)" Class="overlay-icon" />
                                <div class="overlay-name">@overlay.Name</div>
                            </div>

                            <!-- Row 2: Bar Graph -->
                            <div class="overlay-control">
                                <div class="tank-bar-container">
                                    <div class="tank-bar-fill" style="width: @(overlay.Value)%; background-color: @GetTankBarColor(overlay);"></div>
                                    <div class="tank-bar-text">@overlay.Value.ToString("F0")%</div>
                                </div>
                            </div>
                        </div>
                    }
                    else if (overlay.Type == OverlayType.Control)
                    {
                        <div class="overlay-content overlay-card">
                            <!-- Row 1: Icon and Name -->
                            <div class="overlay-header">
                                <MudIcon Icon="@GetControlIcon(overlay.IconName)"
                                        Color="@(overlay.IsOn ? Color.Primary : Color.Default)"
                                        Class="overlay-icon" />
                                <div class="overlay-name">@overlay.Name</div>
                            </div>

                            <!-- Row 2: Control Element -->
                            <div class="overlay-control">
                                @if (overlay.ControlType == "Toggle" && !isEditMode)
                                {
                                    <MudSwitch Value="@overlay.IsOn"
                                              Color="Color.Success"
                                              Class="control-switch"
                                              ValueChanged="@((bool val) => OnControlToggle(overlay, val))" />
                                }
                                else if (overlay.ControlType == "Momentary" && !isEditMode)
                                {
                                    <MudSwitch Value="@overlay.IsOn"
                                              Color="Color.Success"
                                              Class="control-switch"
                                              ValueChanged="@((bool val) => OnControlToggle(overlay, val))" />
                                }
                                else if (overlay.ControlType == "Dimmer" && !isEditMode)
                                {
                                    <div style="width: 100%;">
                                        <MudSlider Value="@overlay.DimmerValue"
                                                  Color="Color.Primary"
                                                  Min="0"
                                                  Max="100"
                                                  Step="5"
                                                  Size="Size.Small"
                                                  ValueChanged="@((int val) => OnDimmerChange(overlay, val))" />
                                        <MudText Typo="Typo.caption" Align="Align.Center" Style="font-size: 0.75rem;">@overlay.DimmerValue%</MudText>
                                    </div>
                                }
                                else if (isEditMode)
                                {
                                    <MudText Typo="Typo.caption" Color="Color.Secondary" Style="font-size: 0.7rem;">@overlay.ControlType</MudText>
                                }
                            </div>
                        </div>
                    }
                </div>
            }
        </div>
    </div>
</div>

@code {
    private List<TankDto>? tanks;
    private List<ControlDto>? controls;
    private string backgroundImage = "";
    private string toolbarPosition = "Left";
    private bool isEditMode = false;
    private List<OverlayItem> overlays = new();
    private OverlayItem? draggedOverlay;
    private ElementReference diagramContainer;
    private double containerWidth = 1;
    private double containerHeight = 1;
    private double dragStartX = 0;
    private double dragStartY = 0;

    protected override async Task OnInitializedAsync()
    {
        await LoadTanks();
        await LoadControls();
        await LoadSettings();
        await LoadOverlayPositions();
        CreateOverlaysFromTanks();
        CreateOverlaysFromControls();

        // Force re-render after settings load
        StateHasChanged();

        // Subscribe to SignalR events
        Telemetry.TankLevelUpdated += OnTankLevelUpdated;
        Telemetry.ControlStateChanged += OnControlStateChanged;

        // Start SignalR connection
        await Telemetry.StartAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Get container dimensions for percentage calculations
            var dimensions = await JSRuntime.InvokeAsync<BoundingBox>("eval",
                @"(function() {
                    const el = document.querySelector('.van-diagram-container');
                    if (el) {
                        return { width: el.offsetWidth, height: el.offsetHeight };
                    }
                    return { width: 1, height: 1 };
                })()");
            containerWidth = dimensions.Width > 0 ? dimensions.Width : 1;
            containerHeight = dimensions.Height > 0 ? dimensions.Height : 1;
        }
    }

    private void OnControlStateChanged(Guid controlId, object state, string name)
    {
        // Update overlay if it exists
        var overlay = overlays.FirstOrDefault(o => o.Id == controlId);
        if (overlay != null)
        {
            overlay.IsOn = Convert.ToBoolean(state);
            InvokeAsync(StateHasChanged);
        }

        // Show toast notification
        Snackbar.Add($"{name} turned {(Convert.ToBoolean(state) ? "ON" : "OFF")}", Severity.Info);
    }

    private async Task LoadSettings()
    {
        try
        {
            var response = await Http.GetFromJsonAsync<SystemConfiguration>("api/settings");
            if (response != null)
            {
                if (!string.IsNullOrEmpty(response.VanDiagramPath))
                {
                    backgroundImage = response.VanDiagramPath;
                    Console.WriteLine($"Loaded van diagram from settings: {backgroundImage}");
                }
                else
                {
                    // No van diagram configured, use default
                    backgroundImage = "/images/Mercedes_Sprinter_LWB_Camper.png";
                    Console.WriteLine("No van diagram configured, using default");
                }

                // Load toolbar position from DrivingSide setting
                toolbarPosition = response.DrivingSide.ToString();
                Console.WriteLine($"Dashboard: Toolbar position set to '{toolbarPosition}' from DrivingSide: {response.DrivingSide}");
            }
            else
            {
                backgroundImage = "/images/Mercedes_Sprinter_LWB_Camper.png";
                toolbarPosition = "Left"; // Ensure default if response is null
                Console.WriteLine("Dashboard: Response null, using default toolbar position 'Left'");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading settings: {ex.Message}");
            // Fallback to default image on error
            backgroundImage = "/images/Mercedes_Sprinter_LWB_Camper.png";
            toolbarPosition = "Left"; // Ensure default on error
        }
    }

    private void CreateOverlaysFromTanks()
    {
        if (tanks == null) return;

        // Remove old tank overlays
        overlays.RemoveAll(o => o.Type == OverlayType.Tank);

        int index = 0;
        foreach (var tank in tanks)
        {
            // Use saved position if available, otherwise use default
            double x = 20 + (index * 15);
            double y = 30 + (index % 2) * 20;

            if (savedPositions.TryGetValue(tank.Id, out var savedPos))
            {
                x = savedPos.X;
                y = savedPos.Y;
            }

            overlays.Add(new OverlayItem
            {
                Id = tank.Id,
                Name = tank.Name,
                Type = OverlayType.Tank,
                Icon = GetTankIcon(tank.Type),
                Value = tank.CurrentLevel,
                AlertWhenOver = tank.AlertWhenOver,
                AlertLevel = tank.AlertLevel,
                X = x,
                Y = y
            });
            index++;
        }
    }

    private void CreateOverlaysFromControls()
    {
        if (controls == null) return;

        // Remove old control overlays
        overlays.RemoveAll(o => o.Type == OverlayType.Control);

        int index = 0;
        foreach (var control in controls)
        {
            bool isOn = false;
            int dimmerValue = 0;

            if (control.Type == "Toggle" || control.Type == "Momentary")
            {
                if (control.State is bool boolState)
                    isOn = boolState;
                else if (control.State is System.Text.Json.JsonElement jsonElement &&
                         jsonElement.ValueKind == System.Text.Json.JsonValueKind.True)
                    isOn = true;
            }
            else if (control.Type == "Dimmer")
            {
                if (control.State is int intState)
                    dimmerValue = intState;
                else if (control.State is System.Text.Json.JsonElement jsonElement &&
                         jsonElement.ValueKind == System.Text.Json.JsonValueKind.Number)
                    dimmerValue = jsonElement.GetInt32();

                isOn = dimmerValue > 0;
            }

            // Use saved position if available, otherwise use default
            double x = 20 + (index * 15);
            double y = 70 + (index % 2) * 20;

            if (savedPositions.TryGetValue(control.Id, out var savedPos))
            {
                x = savedPos.X;
                y = savedPos.Y;
            }

            overlays.Add(new OverlayItem
            {
                Id = control.Id,
                Name = control.Name,
                Type = OverlayType.Control,
                Icon = GetControlIcon(control.IconName),
                IconName = control.IconName,
                ControlType = control.Type,
                IsOn = isOn,
                DimmerValue = dimmerValue,
                ColorValue = new MudColor("#FFFFFF"),
                X = x,
                Y = y
            });
            index++;
        }
    }

    private string GetTankIcon(TankType type)
    {
        return type switch
        {
            TankType.FreshWater => Icons.Material.Filled.WaterDrop,
            TankType.WasteWater => Icons.Material.Filled.Delete,
            TankType.LPG => Icons.Material.Filled.Propane,
            TankType.Fuel => Icons.Material.Filled.LocalGasStation,
            TankType.Battery => Icons.Material.Filled.BatteryFull,
            _ => Icons.Material.Filled.Opacity
        };
    }

    private string GetControlIcon(string iconName)
    {
        return iconName switch
        {
            "lightbulb" => Icons.Material.Filled.Lightbulb,
            "light_mode" => Icons.Material.Filled.LightMode,
            "water_drop" => Icons.Material.Filled.WaterDrop,
            "thermostat" => Icons.Material.Filled.Thermostat,
            "power" => Icons.Material.Filled.Power,
            "fan" => Icons.Material.Filled.Air,
            "heating" => Icons.Material.Filled.LocalFireDepartment,
            "air_conditioner" => Icons.Material.Filled.AcUnit,
            "outlet" => Icons.Material.Filled.PowerSettingsNew,
            "nightlight" => Icons.Material.Filled.Nightlight,
            _ => Icons.Material.Filled.SettingsInputComponent
        };
    }

    private void OnOverlayClick(OverlayItem overlay)
    {
        if (!isEditMode)
        {
            // Show details in a dialog or snackbar
            if (overlay.Type == OverlayType.Tank)
            {
                Snackbar.Add($"{overlay.Name}: {overlay.Value:F1}%", Severity.Info);
            }
        }
    }

    private void OnMouseDown(MouseEventArgs e, OverlayItem overlay)
    {
        if (isEditMode)
        {
            draggedOverlay = overlay;
            dragStartX = e.ClientX;
            dragStartY = e.ClientY;
        }
    }

    private async Task OnMouseMove(MouseEventArgs e)
    {
        if (draggedOverlay != null && isEditMode)
        {
            // Calculate the change in mouse position
            double deltaX = e.ClientX - dragStartX;
            double deltaY = e.ClientY - dragStartY;

            // Convert pixel delta to percentage
            double deltaXPercent = (deltaX / containerWidth) * 100;
            double deltaYPercent = (deltaY / containerHeight) * 100;

            // Update overlay position
            draggedOverlay.X = Math.Max(0, Math.Min(100, draggedOverlay.X + deltaXPercent));
            draggedOverlay.Y = Math.Max(0, Math.Min(100, draggedOverlay.Y + deltaYPercent));

            // Update drag start position for next move
            dragStartX = e.ClientX;
            dragStartY = e.ClientY;

            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task OnMouseUp(MouseEventArgs e)
    {
        if (draggedOverlay != null && isEditMode)
        {
            // Save position to backend
            await SaveOverlayPosition(draggedOverlay);
            draggedOverlay = null;
        }
    }

    // Touch event handlers for mobile devices
    private void OnTouchStart(TouchEventArgs e, OverlayItem overlay)
    {
        if (isEditMode && e.Touches.Length > 0)
        {
            draggedOverlay = overlay;
            var touch = e.Touches[0];
            dragStartX = touch.ClientX;
            dragStartY = touch.ClientY;
        }
    }

    private async Task OnTouchMove(TouchEventArgs e)
    {
        if (draggedOverlay != null && isEditMode && e.Touches.Length > 0)
        {
            var touch = e.Touches[0];

            // Calculate the change in touch position
            double deltaX = touch.ClientX - dragStartX;
            double deltaY = touch.ClientY - dragStartY;

            // Convert pixel delta to percentage
            double deltaXPercent = (deltaX / containerWidth) * 100;
            double deltaYPercent = (deltaY / containerHeight) * 100;

            // Update overlay position
            draggedOverlay.X = Math.Max(0, Math.Min(100, draggedOverlay.X + deltaXPercent));
            draggedOverlay.Y = Math.Max(0, Math.Min(100, draggedOverlay.Y + deltaYPercent));

            // Update drag start position for next move
            dragStartX = touch.ClientX;
            dragStartY = touch.ClientY;

            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task OnTouchEnd(TouchEventArgs e)
    {
        if (draggedOverlay != null && isEditMode)
        {
            // Save position to backend
            await SaveOverlayPosition(draggedOverlay);
            draggedOverlay = null;
        }
    }

    private async Task OnControlToggle(OverlayItem overlay, bool value)
    {
        try
        {
            var response = await Http.PostAsJsonAsync($"api/controls/{overlay.Id}/state", new { state = value });
            if (response.IsSuccessStatusCode)
            {
                overlay.IsOn = value;
                Snackbar.Add($"{overlay.Name} turned {(value ? "ON" : "OFF")}", Severity.Success);
            }
            else
            {
                Snackbar.Add($"Failed to control {overlay.Name}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error controlling {overlay.Name}: {ex.Message}");
            Snackbar.Add($"Error: {ex.Message}", Severity.Error);
        }

        await InvokeAsync(StateHasChanged);
    }

    private async Task OnDimmerChange(OverlayItem overlay, int value)
    {
        try
        {
            var response = await Http.PostAsJsonAsync($"api/controls/{overlay.Id}/state", new { state = value });
            if (response.IsSuccessStatusCode)
            {
                overlay.DimmerValue = value;
                overlay.IsOn = value > 0;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error controlling {overlay.Name}: {ex.Message}");
        }

        await InvokeAsync(StateHasChanged);
    }

    private async Task OnColorChange(OverlayItem overlay, MudColor value)
    {
        try
        {
            var colorHex = value.ToString();
            var response = await Http.PostAsJsonAsync($"api/controls/{overlay.Id}/state", new { state = colorHex });
            if (response.IsSuccessStatusCode)
            {
                overlay.ColorValue = value;
                overlay.IsOn = true;
                Snackbar.Add($"{overlay.Name} color set to {colorHex}", Severity.Success);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error controlling {overlay.Name}: {ex.Message}");
        }

        await InvokeAsync(StateHasChanged);
    }

    private Color GetOverlayColor(OverlayItem overlay)
    {
        if (overlay.Type == OverlayType.Tank)
        {
            if (overlay.AlertWhenOver)
            {
                // Filling tanks (waste water): green when empty, red when full
                if (overlay.Value > 80) return Color.Error;   // Nearly full - bad
                if (overlay.Value > 50) return Color.Warning; // Getting full - warning
                return Color.Success;                          // Empty/low - good
            }
            else
            {
                // Draining tanks (fresh water): green when full, red when empty
                if (overlay.Value < 20) return Color.Error;   // Nearly empty - bad
                if (overlay.Value < 50) return Color.Warning; // Getting low - warning
                return Color.Success;                          // Full/high - good
            }
        }
        return overlay.IsOn ? Color.Success : Color.Default;
    }

    private string GetTankBarColor(OverlayItem overlay)
    {
        if (overlay.AlertWhenOver)
        {
            // Filling tanks (waste water): green when empty, red when full
            if (overlay.Value > 80) return "#f44336"; // Red - nearly full
            if (overlay.Value > 50) return "#ff9800"; // Orange - getting full
            return "#4caf50";                         // Green - empty/low
        }
        else
        {
            // Draining tanks (fresh water): green when full, red when empty
            if (overlay.Value < 20) return "#f44336"; // Red - nearly empty
            if (overlay.Value < 50) return "#ff9800"; // Orange - getting low
            return "#4caf50";                         // Green - full/high
        }
    }

    private async Task LoadTanks()
    {
        try
        {
            var jsonOptions = new System.Text.Json.JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true,
                Converters = { new System.Text.Json.Serialization.JsonStringEnumConverter() }
            };
            tanks = await Http.GetFromJsonAsync<List<TankDto>>("api/tanks", jsonOptions);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading tanks: {ex.Message}");
        }
    }

    private async Task LoadControls()
    {
        try
        {
            controls = await Http.GetFromJsonAsync<List<ControlDto>>("api/controls");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading controls: {ex.Message}");
        }
    }

    private async Task LoadOverlayPositions()
    {
        try
        {
            var positions = await Http.GetFromJsonAsync<List<OverlayPositionDto>>("api/settings/overlay-positions");
            if (positions != null)
            {
                savedPositions = positions.ToDictionary(p => p.Id, p => (p.X, p.Y));
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading overlay positions: {ex.Message}");
            // Non-fatal - will use default positions
        }
    }

    private async Task SaveOverlayPosition(OverlayItem overlay)
    {
        try
        {
            var position = new OverlayPositionDto
            {
                Id = overlay.Id,
                Type = overlay.Type.ToString(),
                X = overlay.X,
                Y = overlay.Y
            };

            var response = await Http.PostAsJsonAsync("api/settings/overlay-positions", position);
            if (response.IsSuccessStatusCode)
            {
                // Update saved positions cache
                savedPositions[overlay.Id] = (overlay.X, overlay.Y);
                Snackbar.Add("Position saved", Severity.Success);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving overlay position: {ex.Message}");
            Snackbar.Add("Failed to save position", Severity.Warning);
        }
    }

    private Dictionary<Guid, (double X, double Y)> savedPositions = new();

    private void OnTankLevelUpdated(Guid tankId, double level, string name)
    {
        // Update the tank in the tanks list
        if (tanks != null)
        {
            var tank = tanks.FirstOrDefault(t => t.Id == tankId);
            if (tank != null)
            {
                tank.CurrentLevel = level;
            }
        }

        // Update the corresponding overlay for real-time display
        var overlay = overlays.FirstOrDefault(o => o.Id == tankId && o.Type == OverlayType.Tank);
        if (overlay != null)
        {
            overlay.Value = level;
            InvokeAsync(StateHasChanged);
        }
    }

    private Color GetTankColor(TankDto tank)
    {
        bool inAlertState = tank.AlertWhenOver
            ? tank.CurrentLevel >= tank.AlertLevel
            : tank.CurrentLevel <= tank.AlertLevel;

        if (!inAlertState)
            return Color.Success;

        // In alert state
        if (tank.AlertWhenOver)
        {
            // Tank getting full
            return tank.CurrentLevel >= 95 ? Color.Error : Color.Warning;
        }
        else
        {
            // Tank running empty
            return tank.CurrentLevel <= 10 ? Color.Error : Color.Warning;
        }
    }

    public async ValueTask DisposeAsync()
    {
        Telemetry.TankLevelUpdated -= OnTankLevelUpdated;
        Telemetry.ControlStateChanged -= OnControlStateChanged;
        await Telemetry.StopAsync();
    }

    public enum TankType
    {
        FreshWater,
        WasteWater,
        LPG,
        Fuel,
        Battery
    }

    public enum OverlayType
    {
        Tank,
        Control
    }

    public class TankDto
    {
        public Guid Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public TankType Type { get; set; }
        public double CurrentLevel { get; set; }
        public double Capacity { get; set; }
        public double AlertLevel { get; set; }
        public bool AlertWhenOver { get; set; }
    }

    public class ControlDto
    {
        public Guid Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public string Type { get; set; } = string.Empty;
        public object State { get; set; } = false;
        public string IconName { get; set; } = string.Empty;
        public string ControlPlugin { get; set; } = "Simulated";
        public Dictionary<string, object>? ControlConfiguration { get; set; }
        public DateTime LastUpdated { get; set; }
        public bool IsActive { get; set; } = true;
    }

    public class OverlayItem
    {
        public Guid Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public OverlayType Type { get; set; }
        public string Icon { get; set; } = string.Empty;
        public string IconName { get; set; } = string.Empty;
        public string ControlType { get; set; } = string.Empty;
        public double Value { get; set; }
        public bool IsOn { get; set; }
        public int DimmerValue { get; set; }
        public MudColor ColorValue { get; set; } = new MudColor("#FFFFFF");
        public double X { get; set; } // Position as percentage
        public double Y { get; set; } // Position as percentage
        public string? ConfiguredAction { get; set; } // For controls
        public bool AlertWhenOver { get; set; } // For tanks - true if alert when filling
        public double AlertLevel { get; set; } // Alert threshold percentage
    }

    public class OverlayPositionDto
    {
        public Guid Id { get; set; }
        public string Type { get; set; } = string.Empty;
        public double X { get; set; }
        public double Y { get; set; }
    }

    public class BoundingBox
    {
        public double Width { get; set; }
        public double Height { get; set; }
    }
}
